.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_workflow_plot_wf_mi_stats_compare_rfx.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_workflow_plot_wf_mi_stats_compare_rfx.py:


Compare between-subjects statistics when computing mutual information
======================================================================

This example illustrates how to define and run a workflow for computing
mutual information and evaluate stastitics. Inference are made within-subjects
(random effect = rfx). 


.. code-block:: default

    import numpy as np

    from frites.simulations import sim_multi_suj_ephy, sim_mi_cc
    from frites.dataset import DatasetEphy
    from frites.workflow import WfMi

    import matplotlib.pyplot as plt
    plt.style.use('seaborn-white')








Simulate electrophysiological data
----------------------------------

Let's start by simulating MEG / EEG electrophysiological data coming from
multiple subjects using the function
:func:`frites.simulations.sim_multi_suj_ephy`. As a result, the `data` output
is a list of length `n_subjects` of arrays, each one with a shape of
n_epochs, n_sites, n_times


.. code-block:: default


    modality = 'meeg'
    n_subjects = 10
    n_epochs = 400
    n_times = 100
    data, roi, time = sim_multi_suj_ephy(n_subjects=n_subjects, n_epochs=n_epochs,
                                         n_times=n_times, modality=modality,
                                         random_state=0)







Simulate mutual information
---------------------------

Once the data have been created, we simulate an increase of mutual
information by creating a continuous variable `y` using the function
:func:`frites.simulations.sim_mi_cc`. This allows to simulate model-based
analysis by computing $I(data; y)$ where `data` and `y` are two continuous
variables


.. code-block:: default


    y, _ = sim_mi_cc(data, snr=.1)







Create an electrophysiological dataset
--------------------------------------

Now, we use the :class:`frites.dataset.DatasetEphy` in order to create a
compatible electrophysiological dataset


.. code-block:: default


    dt = DatasetEphy(data, y, roi=roi, times=time, verbose=False)







Define the workflow
-------------------

We now define the workflow for computing mi and evaluate statistics using the
class :class:`frites.workflow.WfMi`. Here, the type of mutual
information to perform is 'cc' between it's computed between two continuous
variables. And we also specify the inference type 'ffx' for fixed-effect


.. code-block:: default


    mi_type = 'cc'
    inference = 'rfx'
    wf = WfMi(mi_type, inference, verbose=False)







Compute the mutual information and statistics
---------------------------------------------


.. code-block:: default


    # list of corrections for multiple comparison
    mcps = ['maxstat', 'fdr', 'bonferroni']
    kw = dict(output_type='array', n_jobs=1, n_perm=100)
    """
    The `cluster_th` input parameter specifies how the threshold is defined.
    Use either :
    * a float for a manual threshold
    * None and it will be infered using the distribution of permutations
    * 'tfce' for a TFCE threshold
    """
    cluster_th = None  # {float, None, 'tfce'}

    for level in ['testwise', 'cluster']:
        for mcp in mcps:
            print(f'-> RFX / {level} level / MCP={mcp}')
            mi, pvalues = wf.fit(dt, level=level, mcp=mcp, cluster_th=cluster_th,
                                 **kw)
            # remove p-values that exceed 0.05
            pvalues[pvalues >= .05] = 1.

            plt.subplot(212)
            plt.plot(time, pvalues.squeeze(), label=f'ffx-{level}-{mcp}')
            plt.xlabel('Time (s)'), plt.ylabel("P-values")
            plt.title("P-values (rfx)")
            plt.autoscale(tight=True, axis='x')
    plt.legend()

    plt.subplot(211)
    plt.plot(time, mi.squeeze())
    plt.xlabel('Time (s)'), plt.ylabel("Bits")
    plt.title("Mutual information I(C; C)")
    plt.autoscale(tight=True)

    plt.show()



.. image:: /auto_examples/workflow/images/sphx_glr_plot_wf_mi_stats_compare_rfx_001.png
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    -> RFX / testwise level / MCP=maxstat
    -> RFX / testwise level / MCP=fdr
    /home/circleci/project/examples/workflow/plot_wf_mi_stats_compare_rfx.py:95: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
      plt.subplot(212)
    -> RFX / testwise level / MCP=bonferroni
    /home/circleci/project/examples/workflow/plot_wf_mi_stats_compare_rfx.py:95: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
      plt.subplot(212)
    -> RFX / cluster level / MCP=maxstat
    /home/circleci/project/examples/workflow/plot_wf_mi_stats_compare_rfx.py:95: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
      plt.subplot(212)
    -> RFX / cluster level / MCP=fdr
    /home/circleci/project/examples/workflow/plot_wf_mi_stats_compare_rfx.py:95: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
      plt.subplot(212)
    -> RFX / cluster level / MCP=bonferroni
    /home/circleci/project/examples/workflow/plot_wf_mi_stats_compare_rfx.py:95: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
      plt.subplot(212)




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  4.076 seconds)


.. _sphx_glr_download_auto_examples_workflow_plot_wf_mi_stats_compare_rfx.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_wf_mi_stats_compare_rfx.py <plot_wf_mi_stats_compare_rfx.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_wf_mi_stats_compare_rfx.ipynb <plot_wf_mi_stats_compare_rfx.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
